reflection/unsupported.type = Type %s in unsupported

reflection/invalid.assignment.object = Cannot assign object %s to incompatible type %s
reflection/invalid.cast.object = Cannot cast object %s to incompatible type %s

reflection/invalid.type.variable.capture.bounds = Bounds on capture %s are invalid (%s <: %s)

reflection/improper.capture.type = Capture type %s must be proper

reflection/improper.capture.type.upper.bound = Upper bound %s of capture type %s must be proper in bound set %s

reflection/cannot.capture.inference.variable = Cannot capture inference variable %s with type %s in bound set %s
reflection/cannot.capture.multiple.times = Inference variable %s Cannot be captured by two capture conversions %s and %s simultaneous
reflection/cannot.instantiate.inference.variable = Inference variable % has failed to instantiate in bound set %s

reflection/cannot.find.substitution = Cannot find appropriate substitution for %s

reflection/invalid.annotation.value = Annotation property %s has invalid value %s

reflection/invalid.annotation.properties = Annotation properties %s do not exist

reflection/invalid.equality = Cannot add equality bound between %s and %s to bound set %s
reflection/invalid.subtype = Cannot add subtype bound between %s and %s to bound set %s
reflection/invalid.capture.conversion = Cannot add capture conversion %s to bound set %s
reflection/invalid.bound.set = Addition of falsehood into bounds set; %s; %s

reflection/cannot.reduce.constraint = Cannot reduce constraint %s into bound set %s

reflection/invalid.intersection.type = Illegal intersection type %s
reflection/invalid.intersection.types = Illegal intersection type %s; cannot contain both non-interface classes %s and %s

reflection/incompatible.imports = Cannot import both classes %s and %s with the same simple name

reflection/invalid.upper.bound = Type %s is not a valid upper bound

reflection/cannot.copy.inference.variable = Cannot copy inference variable bounds on %s into bound set which already contains it %s

reflection/cannot.resolve.invocation.on.type.with.wildcard.parameters = Cannot resolve any method invocation on type %s as it contains wildcard parameters. Usually this means you should perform capture conversion on the receiver before resolution.
reflection/invalid.variable.arity.invocation = Invocation of %s cannot take variable arity form
reflection/invalid.constructor.arguments = Cannot invoke constructor %s of exact type %s with arguments %s
reflection/invalid.method.arguments = Cannot invoke method %s on exact receiver type %s with arguments %s
reflection/cannot.resolve.override = Cannot resolve override of %s for exact type %s
reflection/cannot.resolve.ambiguity = Cannot resolve invocation ambiguity between candidates %s and %s
reflection/cannot.resolve.applicable = Cannot resolve applicable executable from amongst candidates %s for arguments %s
reflection/cannot.resolve.invocation.type = Cannot resolve generic type parameters for invocation of %s with arguments %s
reflection/incompatible.argument = Given argument %s is incompatible with generic parameter type %s for parameter %s of executable %s
reflection/incompatible.return.types = Declared return type %s is incompatible with overridden methods %s
reflection/must.override.methods = Must provide an overriding implementation for methods %s

reflection/incorrect.enclosing.declaration = Instances of class %s do not enclose instances of declaration %s
